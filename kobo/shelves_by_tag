#! /usr/bin/env python

# By convention we'll use lowercase for all tags and shelf names.

import os, sys
import zipfile
import xml.dom.minidom

import kobo_utils
import epubtag

# Create only shelves in this list. Otherwise ignore tags.
# Don't create shelves for all the zillions of Gutenberg tags.
# Lower-case only.
shelves_wanted = [ "mystery", "science fiction", "science", "astronomy",
                   "history", "short stories", "politics", "philosophy",
                   "dogs", "animals", "humor", "biography", "medicine",
                   "nonfiction", "poetry", "plays", "travel",
                   "war", "civil war", "historical fiction", "adventure",
                   "juvenile", "fantasy" ]

booklist = {}

# First, make a dictionary of all the books we want to index.
# Iterate over dirs of epubs provided on the command line:
for dir in sys.argv[1:]:
    for root, dirs, files in os.walk(dir):
        for f in files:
            if f.endswith(".epub"):
                filepath = os.path.join(root, f)
                try:
                    book = epubtag.EpubBook()
                    book.open(filepath)
                    title = book.get_title()
                    tags = map(str.lower, book.get_tags())
                    booklist[title] = tags
                    print "Local book:", title
                    # print f, tags
                except RuntimeError, e:
                    print e

# The path where the Kobo is mounted:
koboDB = kobo_utils.KoboDB('/dkobo')

# For testing: for a real Kobo, don't specify a path, just connect().
koboDB.connect(os.path.expanduser('~/kobo/d-KoboReader-shelves.sqlite'))

# Shelf names on the Kobo:
kobo_shelves = []
for shelf in koboDB.get_dlist("Shelf", selectors=[ "Name" ]):
    kobo_shelves.append(shelf["Name"])

# What books are in those shelves?
kobo_shelf_content = koboDB.get_dlist("ShelfContent",
                                      selectors=["ShelfName", "ContentId"])

# Get a list of all books on the Kobo:
kobobooks = koboDB.get_dlist("content",
                             selectors = [ 'ContentID', 'Title' ],
                             modifiers="content.BookTitle is null",
                             order="content.Title")

def make_new_shelf(shelfname):
    print "Making a new shelf called", shelfname

def add_new_shelf_content(kobobook, shelfname):
    print "Adding", kobobook["Title"], "to shelf", shelfname

# Iterate over books on the Kobo:
for kobobook in kobobooks:
    if kobobook['Title'] not in booklist:
        # print kobobook['Title'], "is on Kobo but not local"
        continue

    # The book exists both here and on the Kobo.
    # Iterate through the tags and see if it's in appropriate shelves:
    print kobobook['Title'], "has tags", booklist[kobobook['Title']]
    for tag in booklist[kobobook['Title']]:
        if tag not in shelves_wanted:
            continue

        # See if there's already a shelf for this tag:
        if tag not in kobo_shelves:
            make_new_shelf(tag)
            add_new_shelf_content(kobobook, tag)
            continue

        # There's already a shelf named tag. Is this book in it?
        already_on_shelf = False
        for shelf_entry in kobo_shelf_content:
            if shelf_entry['ShelfName'] == tag and \
               shelf_entry['ContentId'] == kobobook['ContentID']:
                # I love how the DB has ContentId and ContentID
                # depending on which table you look at
                already_on_shelf = True

        if already_on_shelf:
            print kobobook['Title'], "is already on shelf", tag
            continue

        add_new_shelf_content(kobobook, tag)

